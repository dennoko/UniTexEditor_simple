// UVIslandBlur.compute
// UVアイランドの境界を越えないブラー処理を行うCompute Shader
// Separable Gaussian Blur（横方向パス）+ マスクベース方式

#pragma kernel CSMainHorizontal
#pragma kernel CSMainVertical

Texture2D<float4> Source;
RWTexture2D<float4> Result;
Texture2D<float> BoundaryMask;  // UV境界マスク（0.0=境界、1.0=内部）

int BlurRadius;
float BlurSigma;

// ガウス関数
float Gaussian(float x, float sigma)
{
    return exp(-(x * x) / (2.0 * sigma * sigma)) / (sqrt(2.0 * 3.14159265359) * sigma);
}

[numthreads(8,8,1)]
void CSMainHorizontal (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);
    
    if (id.x >= width || id.y >= height)
        return;
    
    // 中心ピクセルのマスク値を取得
    float centerMask = BoundaryMask[id.xy];
    
    // 境界付近（マスク値が低い）場合はブラーを弱める
    if (centerMask < 0.1)
    {
        Result[id.xy] = Source[id.xy];
        return;
    }
    
    float4 sum = float4(0, 0, 0, 0);
    float weightSum = 0.0;
    
    // 横方向にブラー
    for (int i = -BlurRadius; i <= BlurRadius; i++)
    {
        int sampleX = clamp((int)id.x + i, 0, (int)width - 1);
        int sampleY = id.y;
        
        // サンプル位置のマスク値を取得
        float sampleMask = BoundaryMask[uint2(sampleX, sampleY)];
        
        // ガウス重み × マスク値でサンプリング重みを計算
        float gaussWeight = Gaussian((float)i, BlurSigma);
        float weight = gaussWeight * sampleMask;
        
        sum += Source[uint2(sampleX, sampleY)] * weight;
        weightSum += weight;
    }
    
    // 正規化
    if (weightSum > 0.0)
    {
        Result[id.xy] = sum / weightSum;
    }
    else
    {
        Result[id.xy] = Source[id.xy];
    }
}

[numthreads(8,8,1)]
void CSMainVertical (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);
    
    if (id.x >= width || id.y >= height)
        return;
    
    // 中心ピクセルのマスク値を取得
    float centerMask = BoundaryMask[id.xy];
    
    // 境界付近（マスク値が低い）場合はブラーを弱める
    if (centerMask < 0.1)
    {
        Result[id.xy] = Source[id.xy];
        return;
    }
    
    float4 sum = float4(0, 0, 0, 0);
    float weightSum = 0.0;
    
    // 縦方向にブラー
    for (int i = -BlurRadius; i <= BlurRadius; i++)
    {
        int sampleX = id.x;
        int sampleY = clamp((int)id.y + i, 0, (int)height - 1);
        
        // サンプル位置のマスク値を取得
        float sampleMask = BoundaryMask[uint2(sampleX, sampleY)];
        
        // ガウス重み × マスク値でサンプリング重みを計算
        float gaussWeight = Gaussian((float)i, BlurSigma);
        float weight = gaussWeight * sampleMask;
        
        sum += Source[uint2(sampleX, sampleY)] * weight;
        weightSum += weight;
    }
    
    // 正規化
    if (weightSum > 0.0)
    {
        Result[id.xy] = sum / weightSum;
    }
    else
    {
        Result[id.xy] = Source[id.xy];
    }
}
