# ARCHITECTURE — UniTexEditor_simple

この文書は `UniTexEditor_simple` の設計方針と主要コンポーネントを説明します。実装チームが速やかに開発を進められるよう、モジュール分割、データフロー、重要な設計決定を記載します。

## 目次
- 高レベル設計
- コンポーネント一覧
- データフロー
- GPU とフォールバック設計
- UV アイランドブラーの設計
- 非破壊ワークフロー
- テスト・性能検討
- 実装ロードマップ（詳細）

## 高レベル設計
目標は「非破壊で高速、拡張しやすい」テクスチャ編集フレームワークを Unity Editor 上に実装すること。処理は可能な限り GPU の Compute Shader で行い、複雑な操作（UV アイランド境界を考慮するブラー等）は GPU または GPU+CPU ハイブリッドで実装します。

### 契約（小さな仕様）
- 入力: ソーステクスチャ（RGBA, 8/16/32bit）、オプションのマスク（グレースケール）、オプションのメッシュ（UV）
- 出力: 編集結果テクスチャ（RGBA） — 非破壊形式でプロジェクト内に保存、または上書きオプションで既存の Asset を更新
- エラー: サポートされないフォーマットや Compute Shader 未サポート時はエディタで警告を出し、CPU フォールバックを提案

## コンポーネント一覧
- Editor UI
  - テクスチャ/マスク/メッシュ選択、スライダ（Hue/Sat/Brightness/Gamma）、ブレンドモード、マスクオプション、出力オプション
  - トーンカーブエディタ（RGB/R/G/B 個別調整）
  - レスポンシブなプレビュー表示（正方形維持、チェッカーボード背景）
- Core Processing Pipeline
  - 処理キュー（非破壊レイヤ管理）
  - 各種処理ノード（ColorCorrectionNode, BlendNode, MaskNode, BlurNode, ToneCurveNode）
- GPU Compute Shaders
  - ColorCorrection.compute（Hue/Sat/Brightness/Gamma）
  - Blend.compute（各種ブレンドモード）
  - MaskApply.compute（マスク適用）
  - UVIslandBlur.compute（UV 境界対応ブラー）
  - ToneCurve.compute（カーブベースの色調整）
- Texture IO
  - Editor 用の読み込み/書き出しユーティリティ（RenderTexture を介して Tex2D に変換）
- UV Utilities
  - メッシュの UV アイランド解析（頂点→UV島マップ生成）、シーム検出、アイランド毎のバウンディングボックス
- Tests
  - 小さなユニットテスト（エディタテストランナー）と簡易性能ベンチマーク

## データフロー（簡潔）
1. ユーザが Editor UI で入力（ソーステクスチャ、マスク、メッシュ、パラメータ）を指定
2. Core が処理ノードを組み立て、GPU 用にコマンドバッファを構築
3. Compute Shader が RenderTexture に書き出す
4. RenderTexture を Texture2D に読み戻し、非破壊レイヤに保存 or Asset を上書き

## GPU とフォールバック設計
- 優先: Compute Shader（高性能）
- フォールバック: Compute が使えない環境では CPU 実装で同等処理を順次行う（遅くなるため警告を表示）
- プラットフォーム: DX11/12、Metal、Vulkan をサポートするが、最初は DirectX コンフィグでの動作確認を行う

## UV アイランドブラーの設計（要点）
- 目標: ブラーが UV シームを越えて混ざらないこと
- 手法案:
  - メッシュの UV を解析し、ピクセル座標（テクスチャ空間）ごとに UV アイランド ID マップを作成
  - ブラー時に近傍サンプルのアイランド ID をチェックし、異なるアイランドのピクセルはブラー重みから除外（または境界減衰）
- 実装:
  - UV アイランド ID マップは一時的なテクスチャ（整数 / RGBA エンコード）として GPU に送り、コンピュートシェーダで参照する
  - ブラーは separable Gaussian (横→縦) を使い、各パスでアイランドチェックを行うことで効率化

## 非破壊ワークフロー
- レイヤシステム: 各編集はレイヤとして保存（Node 系）
- プリセット: パラメータセットを保存/読み込み
- エクスポート: 編集済みテクスチャを新しい Asset として出力、或いは「上書き」オプションで既存 Asset を更新

## テストと性能
- ユニットテスト:
  - ノードごとの小さなテスト
  - マスクの適用／ブレンド結果の数値的検証（小テクスチャ）
- 性能:
  - テストプラン: 2K/4K テクスチャでの処理時間測定
  - プロファイリング: GPU 時間、転送時間、CPU プロセス時間を分離

## エッジケース・考慮点
- 入力が異なる解像度のテクスチャを合成する場合のリサイズ方針
- 異なる色深度（8/16/32bit）をどう扱うか（ガンマ/リニア変換）
- マスクがアルファではなくグレースケールで来るケース
- メモリ（VRAM）の制約と一時テクスチャのライフサイクル管理

## 実装ロードマップ（短期）
1. Editor UI の骨組みと簡易プロトタイプ（ColorCorrection を CPU で実装）
2. Compute Shader プロトタイプ（Hue/Sat/Brightness）を作成し、RT への書き出しを確認
3. Blend & Mask ノードを追加
4. UV アイランド ID マップ生成と separable ブラー（GPU）実装
5. テストと最適化、UI 改善

---

これでアーキテクチャの基礎は固まりました。次は最短で「Editor ウィンドウ + ColorCorrection Compute Shader のプロトタイプ」を実装する流れを提案します。